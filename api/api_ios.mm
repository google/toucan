// Copyright 2025 The Toucan Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <api.h>  // generated by generate_bindings

#include <os/log.h>
#include <sys/time.h>

#include <list>
#include <mutex>
#include <queue>

#include <webgpu/webgpu_cpp.h>

#import <UIKit/UIKit.h>
#import <Metal/Metal.h>

#include "api_internal.h"
#include <api/init_types.h>
#include <ast/ast.h>

@interface ToucanMetalView : UIView {
std::list<UITouch*> activeTouches;
}
@property (nonatomic, strong, readonly) CAMetalLayer *metalLayer;
@end

using namespace Toucan;

class IOSApp {
 public:
  void SetPrimaryView(ToucanMetalView* view) {
    std::lock_guard<std::mutex> lock(primaryViewMutex_);
    primaryView_ = view;
    primaryViewExists_.notify_one();
  }

  void PushEvent(Event* event) {
    std::lock_guard<std::mutex> lock(eventQueueMutex_);
    eventQueue_.push(event);
    eventQueueNonEmpty_.notify_one();
  }

  ToucanMetalView* WaitForPrimaryView() {
    std::unique_lock<std::mutex> lock(primaryViewMutex_);
    while (!primaryView_) {
      primaryViewExists_.wait(lock);
    }
    return primaryView_;
  }

  bool HasPendingEvents() {
    std::lock_guard<std::mutex> lock(eventQueueMutex_);
    return !eventQueue_.empty();
  }

  Event* GetNextEvent() {
    std::unique_lock<std::mutex> lock(eventQueueMutex_);
    while (eventQueue_.empty()) {
      eventQueueNonEmpty_.wait(lock);
    }
    Event* event = eventQueue_.front();
    eventQueue_.pop();
    return event;
  }

private:
  ToucanMetalView        *primaryView_ = nullptr;

  std::queue<Event*>      eventQueue_;

  std::mutex              eventQueueMutex_;
  std::condition_variable eventQueueNonEmpty_;

  std::mutex              primaryViewMutex_;
  std::condition_variable primaryViewExists_;
};

namespace Toucan {

namespace {

IOSApp* gApp;

uint32_t ToToucanEventModifiers(UIKeyModifierFlags modifiers) {
  uint32_t result = 0;
  if (modifiers & UIKeyModifierShift) { result |= static_cast<uint32_t>(EventModifiers::Shift); }
  if (modifiers & UIKeyModifierControl) { result |= static_cast<uint32_t>(EventModifiers::Control); }
  return result;
}

}  // namespace

struct Window {
  ToucanMetalView*  view = nullptr;
};

const uint32_t* Window_GetSize(Window* This) {
  auto size = [This->view bounds].size;
  static uint32_t screenSize[2];
  screenSize[0] = size.width;
  screenSize[1] = size.height;
  return screenSize;
}

Window* Window_Window(const uint32_t* size, const int32_t* position) {
  return new Window{gApp->WaitForPrimaryView()};
}

void Window_Destroy(Window* This) { delete This; }

wgpu::TextureFormat GetPreferredPixelFormat() {
  return wgpu::TextureFormat::BGRA8Unorm;
}

SwapChain* SwapChain_SwapChain(int qualifiers, Type* format, Device* device, Window* window) {
  wgpu::SurfaceConfiguration config;
  config.device = device->device;
  config.format = ToDawnTextureFormat(format);

  auto size = [window->view bounds].size;
  config.width = size.width;
  config.height = size.height;
  config.presentMode = wgpu::PresentMode::Fifo;

  wgpu::SurfaceDescriptorFromMetalLayer metalLayerDesc;
  metalLayerDesc.layer = [window->view metalLayer];
  wgpu::SurfaceDescriptor desc;
  desc.nextInChain = &metalLayerDesc;
  static wgpu::Instance instance = wgpu::CreateInstance({});
  wgpu::Surface surface = instance.CreateSurface(&desc);

  surface.Configure(&config);

  return new SwapChain(surface, device->device, {config.width, config.height, 1}, config.format, [[NSAutoreleasePool alloc] init]);
}

void SwapChain_Present(SwapChain* swapChain) {
  swapChain->surface.Present();
  [static_cast<NSAutoreleasePool*>(swapChain->pool) release];
  swapChain->pool = [[NSAutoreleasePool alloc] init];
}

void SwapChain_Destroy(SwapChain* This) {
  [static_cast<NSAutoreleasePool*>(This->pool) release];
  delete This;
}

Device* Device_Device() {
  wgpu::DeviceDescriptor desc;
  desc.SetUncapturedErrorCallback(
    [](const wgpu::Device&, wgpu::ErrorType type, wgpu::StringView message) {
      os_log(OS_LOG_DEFAULT, "WebGPU Error:\n%{public}s\n", message.data);
    }
  );

  wgpu::Device device = CreateDawnDevice(wgpu::BackendType::Metal, &desc);
  if (!device) { return nullptr; }
  return new Device(device);
}

bool System_IsRunning() { return true; }

bool System_HasPendingEvents() {
  return gApp->HasPendingEvents();
}

Event* System_GetNextEvent() {
  return gApp->GetNextEvent();
}

const uint32_t* System_GetScreenSize() {
  auto primaryView = gApp->WaitForPrimaryView();
  auto size = [primaryView bounds].size;
  static uint32_t screenSize[2];
  screenSize[0] = size.width;
  screenSize[1] = size.height;

  return screenSize;
}

double System_GetCurrentTime() {
  struct timeval now;

  gettimeofday(&now, NULL);
  return static_cast<double>(now.tv_sec) + static_cast<double>(now.tv_usec) / 1000000.0;
}

void System_Print(Array* buffer) {
  NSString* str = [[NSString alloc] initWithBytes:buffer->ptr
                                           length:buffer->length
                                         encoding:NSUTF8StringEncoding];

  os_log(OS_LOG_DEFAULT, "%{public}@", str);
}

void System_PrintLine(Array* buffer) {
  NSString* str = [[NSString alloc] initWithBytes:buffer->ptr
                                           length:buffer->length
                                         encoding:NSUTF8StringEncoding];

  os_log(OS_LOG_DEFAULT, "%{public}@\n", str);
}

};  // namespace Toucan

@interface ToucanAppDelegate: UIResponder <UIApplicationDelegate>
@end

@interface ToucanViewController : UIViewController
@end

@interface ToucanSceneDelegate : UIResponder <UIWindowSceneDelegate>
@end

using namespace Toucan;

extern "C" {
extern void        toucan_main();
const Type* const* _type_list;
}

int main(int argc, char** argv) {
  TypeTable   types;
  _type_list = InitTypes(&types);
  types.ComputeFieldOffsets();
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  std::vector<char> stack(STACK_SIZE);
  pthread_attr_setstack(&attr, stack.data(), STACK_SIZE);
  pthread_t toucan_thread;
  IOSApp app;
  gApp = &app;
  auto toucan_main_wrapper = [](void*) -> void* { toucan_main(); return nullptr; };
  pthread_create(&toucan_thread, &attr, toucan_main_wrapper, nullptr);
  @autoreleasepool {
    return UIApplicationMain(argc, argv, nil, NSStringFromClass(ToucanAppDelegate.class));
  }
  pthread_join(toucan_thread, nullptr);
  return 0;
}

@implementation ToucanAppDelegate

- (UISceneConfiguration *)application:(UIApplication *)application configurationForConnectingSceneSession:(UISceneSession *)connectingSceneSession options:(UISceneConnectionOptions *)options {
    UISceneConfiguration *configuration = [[UISceneConfiguration alloc] initWithName:nil sessionRole:connectingSceneSession.role];
    configuration.delegateClass = ToucanSceneDelegate.class;
    return configuration;
}

@end

@implementation ToucanSceneDelegate

@synthesize window = _window;

- (void)scene:(UIScene *)scene willConnectToSession:(UISceneSession *)session options:(UISceneConnectionOptions *)connectionOptions {
  self.window = [[UIWindow alloc] initWithWindowScene:(UIWindowScene*) scene];
  self.window.rootViewController = [[ToucanViewController alloc] init];
  [self.window makeKeyAndVisible];
}

@end

@implementation ToucanViewController

- (void)viewDidLoad {
  [super viewDidLoad];

  auto primaryView = [[ToucanMetalView alloc] initWithFrame:self.view.frame];

  CAMetalLayer* layer = (CAMetalLayer*) primaryView.layer;
  [layer setDevice:MTLCreateSystemDefaultDevice()];
  [layer setPixelFormat:MTLPixelFormatBGRA8Unorm];
  [layer setFramebufferOnly:YES];

  [self.view addSubview:primaryView];
  gApp->SetPrimaryView(primaryView);
}

@end

@implementation ToucanMetalView

+ (Class)layerClass {
    return [CAMetalLayer class];
}

- (instancetype)initWithFrame:(CGRect)frame {
    self = [super initWithFrame:frame];
    _metalLayer = (CAMetalLayer *) self.layer;
    _metalLayer.pixelFormat = MTLPixelFormatBGRA8Unorm;
    _metalLayer.framebufferOnly = YES;
    self.multipleTouchEnabled = true;
    self.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
    return self;
}

- (void) layoutSubviews {
  [super layoutSubviews];

  gApp->PushEvent(new Event{.type = EventType::Unknown});
}

- (void) touchEvent:(EventType) type {
  auto event = new Event();
  event->type = type;
  int i = 0;
  for (UITouch* touch : activeTouches) {
    auto position = [touch locationInView:self];
    event->touches[i][0] = position.x;
    event->touches[i][1] = position.y;
    i++;
    if (i == 10) break;
  }
  event->numTouches = i;
  gApp->PushEvent(event);
}

- (void) touchesBegan:(NSSet<UITouch*>*) touches withEvent:(UIEvent*) e {
  for (UITouch* touch in touches) {
    activeTouches.push_back(touch);
  }
  [self touchEvent:EventType::TouchStart];
}

- (void) touchesMoved:(NSSet<UITouch*>*) touches withEvent:(UIEvent*) e {
  [self touchEvent:EventType::TouchMove];
}

- (void)touchesEnded:(NSSet<UITouch*>*) touches withEvent:(UIEvent*) e {
  for (UITouch* touch in touches) {
    activeTouches.remove(touch);
  }
  [self touchEvent:EventType::TouchEnd];
}

@end
